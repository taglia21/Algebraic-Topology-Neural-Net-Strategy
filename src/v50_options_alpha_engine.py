#!/usr/bin/env python3
"""
V50 Options Alpha Engine
========================
Advanced options trading engine using TDA (Topological Data Analysis) 
and Neural Networks for signal generation and risk management.

Features:
- Greeks calculation (Delta, Gamma, Theta, Vega, Rho)
- IV surface modeling and skew analysis
- Multi-timeframe signal aggregation
- Position sizing based on Kelly criterion
- Spread strategy optimization (verticals, iron condors, calendars)
- Real-time P&L tracking with Greeks hedging
"""

import numpy as np
import pandas as pd
from scipy.stats import norm
from scipy.optimize import brentq, minimize
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Any
from enum import Enum
from datetime import datetime, timedelta
import logging
import json

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class OptionType(Enum):
    CALL = "call"
    PUT = "put"


class StrategyType(Enum):
    LONG_CALL = "long_call"
    LONG_PUT = "long_put"
    SHORT_CALL = "short_call"
    SHORT_PUT = "short_put"
    BULL_CALL_SPREAD = "bull_call_spread"
    BEAR_PUT_SPREAD = "bear_put_spread"
    IRON_CONDOR = "iron_condor"
    IRON_BUTTERFLY = "iron_butterfly"
    CALENDAR_SPREAD = "calendar_spread"
    STRADDLE = "straddle"
    STRANGLE = "strangle"
    COVERED_CALL = "covered_call"
    CASH_SECURED_PUT = "cash_secured_put"



@dataclass
class OptionContract:
    """Represents a single options contract."""
    symbol: str
    underlying: str
    strike: float
    expiration: datetime
    option_type: OptionType
    bid: float = 0.0
    ask: float = 0.0
    last: float = 0.0
    volume: int = 0
    open_interest: int = 0
    implied_volatility: float = 0.0
    delta: float = 0.0
    gamma: float = 0.0
    theta: float = 0.0
    vega: float = 0.0
    rho: float = 0.0
    
    @property
    def mid_price(self) -> float:
        return (self.bid + self.ask) / 2 if self.bid > 0 else self.last
    
    @property
    def days_to_expiration(self) -> int:
        return max(0, (self.expiration - datetime.now()).days)
    
    @property
    def time_to_expiration(self) -> float:
        """Time to expiration in years."""
        return max(0.001, self.days_to_expiration / 365.0)


@dataclass
class OptionsPosition:
    """Represents an options position."""
    contract: OptionContract
    quantity: int  # Positive for long, negative for short
    entry_price: float
    entry_time: datetime
    
    @property
    def current_value(self) -> float:
        return self.contract.mid_price * abs(self.quantity) * 100
    
    @property
    def cost_basis(self) -> float:
        return self.entry_price * abs(self.quantity) * 100
    
    @property
    def unrealized_pnl(self) -> float:
        if self.quantity > 0:  # Long position
            return (self.contract.mid_price - self.entry_price) * self.quantity * 100
        else:  # Short position
            return (self.entry_price - self.contract.mid_price) * abs(self.quantity) * 100


@dataclass
class OptionsSignal:
    """Signal generated by the options alpha engine."""
    timestamp: datetime
    symbol: str
    strategy: StrategyType
    direction: str  # 'bullish', 'bearish', 'neutral'
    confidence: float  # 0.0 to 1.0
    expected_return: float
    max_loss: float
    probability_of_profit: float
    iv_percentile: float
    recommended_strikes: List[float] = field(default_factory=list)
    recommended_expiration: Optional[datetime] = None
    rationale: str = ""
    
    def to_dict(self) -> Dict:
        return {
            'timestamp': self.timestamp.isoformat(),
            'symbol': self.symbol,
            'strategy': self.strategy.value,
            'direction': self.direction,
            'confidence': self.confidence,
            'expected_return': self.expected_return,
            'max_loss': self.max_loss,
            'pop': self.probability_of_profit,
            'iv_percentile': self.iv_percentile,
            'rationale': self.rationale
        }



class BlackScholes:
    """Black-Scholes option pricing model with Greeks."""
    
    @staticmethod
    def d1(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate d1 parameter."""
        if T <= 0 or sigma <= 0:
            return 0.0
        return (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
    
    @staticmethod
    def d2(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate d2 parameter."""
        if T <= 0 or sigma <= 0:
            return 0.0
        return BlackScholes.d1(S, K, T, r, sigma) - sigma * np.sqrt(T)
    
    @staticmethod
    def call_price(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate call option price."""
        if T <= 0:
            return max(0, S - K)
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        d2 = BlackScholes.d2(S, K, T, r, sigma)
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    
    @staticmethod
    def put_price(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate put option price."""
        if T <= 0:
            return max(0, K - S)
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        d2 = BlackScholes.d2(S, K, T, r, sigma)
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    
    @staticmethod
    def delta(S: float, K: float, T: float, r: float, sigma: float, option_type: OptionType) -> float:
        """Calculate option delta."""
        if T <= 0:
            if option_type == OptionType.CALL:
                return 1.0 if S > K else 0.0
            else:
                return -1.0 if S < K else 0.0
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        if option_type == OptionType.CALL:
            return norm.cdf(d1)
        else:
            return norm.cdf(d1) - 1
    
    @staticmethod
    def gamma(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate option gamma (same for calls and puts)."""
        if T <= 0 or sigma <= 0:
            return 0.0
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        return norm.pdf(d1) / (S * sigma * np.sqrt(T))
    
    @staticmethod
    def theta(S: float, K: float, T: float, r: float, sigma: float, option_type: OptionType) -> float:
        """Calculate option theta (per day)."""
        if T <= 0:
            return 0.0
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        d2 = BlackScholes.d2(S, K, T, r, sigma)
        term1 = -(S * norm.pdf(d1) * sigma) / (2 * np.sqrt(T))
        if option_type == OptionType.CALL:
            term2 = -r * K * np.exp(-r * T) * norm.cdf(d2)
        else:
            term2 = r * K * np.exp(-r * T) * norm.cdf(-d2)
        return (term1 + term2) / 365  # Per day
    
    @staticmethod
    def vega(S: float, K: float, T: float, r: float, sigma: float) -> float:
        """Calculate option vega (for 1% change in IV)."""
        if T <= 0:
            return 0.0
        d1 = BlackScholes.d1(S, K, T, r, sigma)
        return S * norm.pdf(d1) * np.sqrt(T) / 100  # Per 1% IV change
    
    @staticmethod
    def rho(S: float, K: float, T: float, r: float, sigma: float, option_type: OptionType) -> float:
        """Calculate option rho (for 1% change in rate)."""
        if T <= 0:
            return 0.0
        d2 = BlackScholes.d2(S, K, T, r, sigma)
        if option_type == OptionType.CALL:
            return K * T * np.exp(-r * T) * norm.cdf(d2) / 100
        else:
            return -K * T * np.exp(-r * T) * norm.cdf(-d2) / 100
    
    @staticmethod
    def implied_volatility(price: float, S: float, K: float, T: float, r: float, 
                           option_type: OptionType, max_iter: int = 100) -> float:
        """Calculate implied volatility using Brent's method."""
        if T <= 0:
            return 0.0
        
        def objective(sigma):
            if option_type == OptionType.CALL:
                return BlackScholes.call_price(S, K, T, r, sigma) - price
            else:
                return BlackScholes.put_price(S, K, T, r, sigma) - price
        
        try:
            iv = brentq(objective, 0.001, 5.0, maxiter=max_iter)
            return iv
        except (ValueError, RuntimeError):
            # Fallback to Newton-Raphson
            sigma = 0.3  # Initial guess
            for _ in range(max_iter):
                if option_type == OptionType.CALL:
                    theo_price = BlackScholes.call_price(S, K, T, r, sigma)
                else:
                    theo_price = BlackScholes.put_price(S, K, T, r, sigma)
                vega = BlackScholes.vega(S, K, T, r, sigma) * 100
                if abs(vega) < 1e-10:
                    break
                sigma = sigma - (theo_price - price) / vega
                if sigma <= 0:
                    sigma = 0.001
                if abs(theo_price - price) < 0.001:
                    break
            return max(0.001, min(sigma, 5.0))



class IVSurfaceAnalyzer:
    """Analyzes IV surface for trading opportunities."""
    
    def __init__(self, lookback_days: int = 252):
        self.lookback_days = lookback_days
        self.iv_history: Dict[str, List[float]] = {}
    
    def update_iv_history(self, symbol: str, iv: float):
        """Add new IV observation."""
        if symbol not in self.iv_history:
            self.iv_history[symbol] = []
        self.iv_history[symbol].append(iv)
        # Keep only lookback period
        if len(self.iv_history[symbol]) > self.lookback_days:
            self.iv_history[symbol] = self.iv_history[symbol][-self.lookback_days:]
    
    def get_iv_percentile(self, symbol: str, current_iv: float) -> float:
        """Calculate current IV percentile vs historical."""
        if symbol not in self.iv_history or len(self.iv_history[symbol]) < 20:
            return 50.0  # Default to neutral
        hist = np.array(self.iv_history[symbol])
        return float(np.sum(hist < current_iv) / len(hist) * 100)
    
    def get_iv_rank(self, symbol: str, current_iv: float) -> float:
        """Calculate IV rank (current vs min-max range)."""
        if symbol not in self.iv_history or len(self.iv_history[symbol]) < 20:
            return 50.0
        hist = np.array(self.iv_history[symbol])
        iv_min, iv_max = hist.min(), hist.max()
        if iv_max == iv_min:
            return 50.0
        return float((current_iv - iv_min) / (iv_max - iv_min) * 100)
    
    def analyze_skew(self, calls: List[OptionContract], puts: List[OptionContract],
                     underlying_price: float) -> Dict[str, float]:
        """Analyze put-call skew for risk sentiment."""
        if not calls or not puts:
            return {'skew': 0.0, 'term_structure': 0.0}
        
        # Find ATM options
        atm_call = min(calls, key=lambda x: abs(x.strike - underlying_price))
        atm_put = min(puts, key=lambda x: abs(x.strike - underlying_price))
        
        # Find 25-delta options (approx 5% OTM)
        otm_threshold = underlying_price * 0.05
        otm_puts = [p for p in puts if p.strike < underlying_price - otm_threshold]
        otm_calls = [c for c in calls if c.strike > underlying_price + otm_threshold]
        
        skew = 0.0
        if otm_puts and atm_call.implied_volatility > 0:
            avg_otm_put_iv = np.mean([p.implied_volatility for p in otm_puts[:3]])
            skew = (avg_otm_put_iv - atm_call.implied_volatility) / atm_call.implied_volatility
        
        return {
            'skew': skew,
            'atm_iv': atm_call.implied_volatility,
            'put_call_iv_ratio': atm_put.implied_volatility / atm_call.implied_volatility if atm_call.implied_volatility > 0 else 1.0
        }



class V50OptionsAlphaEngine:
    """
    Main options alpha engine that combines TDA signals with options strategies.
    Integrates with the Team of Rivals framework for consensus-based trading.
    """
    
    def __init__(self, risk_free_rate: float = 0.05, max_position_pct: float = 0.05,
                 min_confidence: float = 0.6, paper_trading: bool = True):
        self.risk_free_rate = risk_free_rate
        self.max_position_pct = max_position_pct
        self.min_confidence = min_confidence
        self.paper_trading = paper_trading
        
        self.iv_analyzer = IVSurfaceAnalyzer()
        self.positions: List[OptionsPosition] = []
        self.signals_history: List[OptionsSignal] = []
        self.portfolio_value = 100000.0  # Paper trading starting value
        
        # Strategy preference based on IV environment
        self.high_iv_strategies = [
            StrategyType.SHORT_PUT,
            StrategyType.IRON_CONDOR,
            StrategyType.COVERED_CALL,
            StrategyType.CASH_SECURED_PUT
        ]
        self.low_iv_strategies = [
            StrategyType.LONG_CALL,
            StrategyType.LONG_PUT,
            StrategyType.STRADDLE,
            StrategyType.CALENDAR_SPREAD
        ]
        
        logger.info(f"V50 Options Alpha Engine initialized (paper={paper_trading})")
    
    def calculate_greeks(self, contract: OptionContract, underlying_price: float) -> OptionContract:
        """Calculate and update all Greeks for a contract."""
        S = underlying_price
        K = contract.strike
        T = contract.time_to_expiration
        r = self.risk_free_rate
        sigma = contract.implied_volatility if contract.implied_volatility > 0 else 0.3
        
        contract.delta = BlackScholes.delta(S, K, T, r, sigma, contract.option_type)
        contract.gamma = BlackScholes.gamma(S, K, T, r, sigma)
        contract.theta = BlackScholes.theta(S, K, T, r, sigma, contract.option_type)
        contract.vega = BlackScholes.vega(S, K, T, r, sigma)
        contract.rho = BlackScholes.rho(S, K, T, r, sigma, contract.option_type)
        
        return contract
    
    def select_strategy(self, iv_percentile: float, direction: str, 
                        days_to_earnings: Optional[int] = None) -> StrategyType:
        """Select optimal strategy based on IV environment and market direction."""
        
        # High IV environment (>70th percentile) - sell premium
        if iv_percentile > 70:
            if direction == 'bullish':
                return StrategyType.CASH_SECURED_PUT
            elif direction == 'bearish':
                return StrategyType.COVERED_CALL
            else:  # neutral
                return StrategyType.IRON_CONDOR
        
        # Low IV environment (<30th percentile) - buy premium
        elif iv_percentile < 30:
            if direction == 'bullish':
                return StrategyType.LONG_CALL
            elif direction == 'bearish':
                return StrategyType.LONG_PUT
            else:  # neutral
                if days_to_earnings and days_to_earnings < 14:
                    return StrategyType.STRADDLE
                return StrategyType.CALENDAR_SPREAD
        
        # Medium IV - use spreads
        else:
            if direction == 'bullish':
                return StrategyType.BULL_CALL_SPREAD
            elif direction == 'bearish':
                return StrategyType.BEAR_PUT_SPREAD
            else:
                return StrategyType.IRON_BUTTERFLY
    
    def calculate_position_size(self, strategy: StrategyType, max_loss: float,
                                confidence: float) -> int:
        """Calculate position size using modified Kelly criterion."""
        max_risk = self.portfolio_value * self.max_position_pct
        
        # Kelly fraction = (p * b - q) / b where p=win prob, q=lose prob, b=odds
        # Modified to be more conservative (half Kelly)
        win_prob = 0.5 + (confidence - 0.5) * 0.5  # Map confidence to win probability
        expected_edge = win_prob - 0.5
        kelly_fraction = max(0.01, min(0.25, expected_edge * 2))  # Cap at 25%
        
        risk_budget = max_risk * kelly_fraction
        
        if max_loss > 0:
            contracts = int(risk_budget / (max_loss * 100))
        else:
            contracts = 1
        
        return max(1, min(contracts, 10))  # Min 1, max 10 contracts

    
    def generate_signal(self, symbol: str, underlying_price: float,
                        tda_signal: Dict[str, Any], nn_prediction: float,
                        option_chain: Optional[Dict] = None) -> Optional[OptionsSignal]:
        """
        Generate options trading signal from TDA+NN inputs.
        
        Args:
            symbol: Underlying symbol
            underlying_price: Current price
            tda_signal: Signal from TDA analysis (persistence, betti numbers)
            nn_prediction: Neural network prediction (-1 to 1)
            option_chain: Optional options chain data
        """
        # Extract TDA metrics
        persistence = tda_signal.get('persistence_score', 0.5)
        trend_strength = tda_signal.get('trend_strength', 0.0)
        regime = tda_signal.get('regime', 'neutral')
        
        # Combine signals
        combined_signal = 0.4 * nn_prediction + 0.3 * (persistence - 0.5) * 2 + 0.3 * trend_strength
        
        # Determine direction
        if combined_signal > 0.2:
            direction = 'bullish'
        elif combined_signal < -0.2:
            direction = 'bearish'
        else:
            direction = 'neutral'
        
        # Calculate confidence
        confidence = min(1.0, abs(combined_signal) + 0.3)  # Base confidence + signal strength
        
        if confidence < self.min_confidence:
            logger.info(f"Signal confidence {confidence:.2f} below threshold {self.min_confidence}")
            return None
        
        # Get IV percentile (mock if no chain)
        iv_percentile = 50.0
        if option_chain:
            atm_iv = option_chain.get('atm_iv', 0.3)
            iv_percentile = self.iv_analyzer.get_iv_percentile(symbol, atm_iv)
            self.iv_analyzer.update_iv_history(symbol, atm_iv)
        
        # Select strategy
        strategy = self.select_strategy(iv_percentile, direction)
        
        # Calculate expected metrics based on strategy
        if strategy in self.high_iv_strategies:
            expected_return = 0.15  # Premium capture
            max_loss = underlying_price * 0.10  # 10% max move risk
            pop = 0.70  # Higher POP for premium selling
        else:
            expected_return = 0.30  # Directional plays
            max_loss = underlying_price * 0.03  # Premium paid
            pop = 0.45  # Lower POP but higher reward
        
        signal = OptionsSignal(
            timestamp=datetime.now(),
            symbol=symbol,
            strategy=strategy,
            direction=direction,
            confidence=confidence,
            expected_return=expected_return,
            max_loss=max_loss,
            probability_of_profit=pop,
            iv_percentile=iv_percentile,
            rationale=f"TDA regime: {regime}, NN pred: {nn_prediction:.2f}, combined: {combined_signal:.2f}"
        )
        
        self.signals_history.append(signal)
        logger.info(f"Generated signal: {symbol} {strategy.value} ({direction}) conf={confidence:.2f}")
        
        return signal
    
    def get_portfolio_greeks(self) -> Dict[str, float]:
        """Calculate aggregate portfolio Greeks."""
        total_delta = sum(p.contract.delta * p.quantity * 100 for p in self.positions)
        total_gamma = sum(p.contract.gamma * p.quantity * 100 for p in self.positions)
        total_theta = sum(p.contract.theta * p.quantity * 100 for p in self.positions)
        total_vega = sum(p.contract.vega * p.quantity * 100 for p in self.positions)
        
        return {
            'delta': total_delta,
            'gamma': total_gamma,
            'theta': total_theta,
            'vega': total_vega,
            'positions': len(self.positions)
        }
    
    def get_status(self) -> Dict[str, Any]:
        """Get engine status for monitoring."""
        greeks = self.get_portfolio_greeks()
        total_pnl = sum(p.unrealized_pnl for p in self.positions)
        
        return {
            'portfolio_value': self.portfolio_value,
            'unrealized_pnl': total_pnl,
            'positions_count': len(self.positions),
            'signals_generated': len(self.signals_history),
            'portfolio_greeks': greeks,
            'paper_trading': self.paper_trading,
            'last_signal': self.signals_history[-1].to_dict() if self.signals_history else None
        }



def demo_options_engine():
    """Demonstrate the options alpha engine."""
    print("=" * 60)
    print("V50 OPTIONS ALPHA ENGINE - DEMO")
    print("=" * 60)
    
    # Initialize engine
    engine = V50OptionsAlphaEngine(paper_trading=True)
    
    # Test Black-Scholes pricing
    print("\n[Black-Scholes Test]")
    S, K, T, r, sigma = 100, 100, 0.25, 0.05, 0.20
    call_price = BlackScholes.call_price(S, K, T, r, sigma)
    put_price = BlackScholes.put_price(S, K, T, r, sigma)
    print(f"ATM Call (S={S}, K={K}, T={T}yr, Ïƒ={sigma}): ${call_price:.2f}")
    print(f"ATM Put: ${put_price:.2f}")
    
    # Test Greeks
    print("\n[Greeks Calculation]")
    delta_c = BlackScholes.delta(S, K, T, r, sigma, OptionType.CALL)
    gamma = BlackScholes.gamma(S, K, T, r, sigma)
    theta_c = BlackScholes.theta(S, K, T, r, sigma, OptionType.CALL)
    vega = BlackScholes.vega(S, K, T, r, sigma)
    print(f"Call Delta: {delta_c:.4f}")
    print(f"Gamma: {gamma:.4f}")
    print(f"Theta (daily): ${theta_c:.4f}")
    print(f"Vega (per 1% IV): ${vega:.4f}")
    
    # Test IV calculation
    print("\n[Implied Volatility]")
    iv = BlackScholes.implied_volatility(call_price, S, K, T, r, OptionType.CALL)
    print(f"Recovered IV: {iv:.4f} (expected: {sigma})")
    
    # Test signal generation
    print("\n[Signal Generation]")
    tda_signal = {
        'persistence_score': 0.72,
        'trend_strength': 0.35,
        'regime': 'bullish_momentum'
    }
    nn_prediction = 0.45  # Bullish
    
    signal = engine.generate_signal(
        symbol='AAPL',
        underlying_price=185.50,
        tda_signal=tda_signal,
        nn_prediction=nn_prediction
    )
    
    if signal:
        print(f"Symbol: {signal.symbol}")
        print(f"Strategy: {signal.strategy.value}")
        print(f"Direction: {signal.direction}")
        print(f"Confidence: {signal.confidence:.2%}")
        print(f"Expected Return: {signal.expected_return:.2%}")
        print(f"Probability of Profit: {signal.probability_of_profit:.2%}")
        print(f"Rationale: {signal.rationale}")
    
    # Test strategy selection across IV environments
    print("\n[Strategy Selection Matrix]")
    for iv_pct in [20, 50, 80]:
        for direction in ['bullish', 'bearish', 'neutral']:
            strategy = engine.select_strategy(iv_pct, direction)
            print(f"IV={iv_pct}%, {direction:8s} -> {strategy.value}")
    
    # Get engine status
    print("\n[Engine Status]")
    status = engine.get_status()
    print(json.dumps(status, indent=2, default=str))
    
    print("\n" + "=" * 60)
    print("OPTIONS ENGINE READY FOR INTEGRATION")
    print("=" * 60)
    
    return engine


if __name__ == "__main__":
    demo_options_engine()

